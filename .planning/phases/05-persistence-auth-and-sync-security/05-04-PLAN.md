---
phase: 05-persistence-auth-and-sync-security
plan: 04
type: execute
wave: 2
depends_on:
  - 05-01
  - 05-02
files_modified:
  - src/features/workspace/storage-merge.service.ts
  - src/features/workspace/storage-sync.service.ts
  - src/features/workspace/hooks/useMergeOnSignIn.ts
autonomous: true
requirements:
  - SYN-01
  - SYN-02
  - SYN-03
user_setup: []

must_haves:
  truths:
    - "Conflicting decisions are preserved with unique identifiers"
    - "Signing in merges local decisions into authenticated account"
    - "Toast notification shows merge count: 'X decisions merged'"
    - "Signing out clears local storage and auth tokens"
  artifacts:
    - path: "src/features/workspace/storage-merge.service.ts"
      provides: "Merge service for local-to-Convex decisions"
      exports: ["mergeDecisions", "resolveConflict"]
    - path: "src/features/workspace/storage-sync.service.ts"
      provides: "Sync service for Convex localStorage cache"
      exports: ["cacheFromConvex", "clearCache"]
    - path: "src/features/workspace/hooks/useMergeOnSignIn.ts"
      provides: "Merge logic for sign-in flow"
      contains: "useMergeOnSignIn"
  key_links:
    - from: "src/features/workspace/hooks/useMergeOnSignIn.ts"
      to: "convex/decisions"
      via: "Convex mutations for creating decisions"
      pattern: "mutation\\.create\\(\\)"
    - from: "src/features/workspace/storage-merge.service.ts"
      to: "src/features/auth/storage/local.storage.ts"
      via: "loadDecisions for local decisions"
      pattern: "localStorageService\\.loadDecisions\\(\\)"
---

<objective>
Build storage merge and sync services with merge-on-sign-in hook.

Purpose: Enable local-to-authenticated merge on sign-in (SYN-01, SYN-02) with conflict resolution and notifications.
Output: Merge service, sync service, and hook that handles merge on sign-in with toast notifications.
</objective>

<execution_context>
@C:/Users/aaron/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/aaron/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/features/auth/storage/local.storage.ts
@convex/decisions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create storage merge service</name>
  <files>
    - src/features/workspace/storage-merge.service.ts
  </files>
  <action>
    Create src/features/workspace/storage-merge.service.ts:

    1. Import localStorageService from auth/storage/local.storage.ts

    2. resolveConflict(localDecision: LocalDecision, existingDecision: any): LocalDecision
       - Check if UUIDs conflict (same id)
       - If conflict: Generate new UUID for local decision using generateDecisionId()
       - Update decision.id to new UUID
       - If no conflict: Return local decision unchanged
       - Return resolved decision

    3. mergeDecisions(convex, userId: string): Promise<{ mergedCount: number }>
       - Load local decisions from localStorageService.loadDecisions()
       - If null or empty: Return { mergedCount: 0 }

       - For each local decision:
         - Query Convex to check if decision with same id exists for this user
         - Call convex.mutations.decisions.get({ id: decision.id })
         - If exists (conflict): Call resolveConflict() to regenerate UUID
         - Create decision in Convex: convex.mutations.decisions.create({ ...decision, userId })
         - Increment mergedCount

       - Clear local decisions: localStorageService.clearAll()

       - Return { mergedCount }

    IMPORTANT: Merge preserves decision data by regenerating UUID only when conflicts exist. Server data is never deleted on sign-out.
  </action>
  <verify>
    - src/features/workspace/storage-merge.service.ts exists
    - resolveConflict regenerates UUID on conflict
    - mergeDecisions loads local decisions and creates in Convex
    - mergeDecisions checks for UUID conflicts before creating
    - mergeDecisions clears local storage after merge
    - mergeDecisions returns mergedCount
  </verify>
  <done>
    Storage merge service handles local-to-Convex decision migration with conflict resolution.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create storage sync service for authenticated cache</name>
  <files>
    - src/features/workspace/storage-sync.service.ts
  </files>
  <action>
    Create src/features/workspace/storage-sync.service.ts:

    1. Import localStorageService from auth/storage/local.storage.ts

    2. cacheFromConvex(convexDecisions: any[]): void
       - Clear local cache: localStorageService.clearAll()
       - For each Convex decision:
         - Convert to LocalDecision format (Convex already has LocalDecision shape)
         - Save to localStorage: localStorageService.saveDecision(decision)
       - Set lastSyncedAt to current timestamp

    3. clearCache(): void
       - Call localStorageService.clearAll()

    IMPORTANT: When signed in, localStorage is only cache. Convex is source of truth. Cache is kept in sync for offline access.
  </action>
  <verify>
    - src/features/workspace/storage-sync.service.ts exists
    - cacheFromConvex saves Convex decisions to localStorage cache
    - cacheFromConvex clears before writing fresh cache
    - clearCache removes all cached decisions
  </verify>
  <done>
    Storage sync service manages localStorage cache for authenticated users.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create useMergeOnSignIn hook</name>
  <files>
    - src/features/workspace/hooks/useMergeOnSignIn.ts
  </files>
  <action>
    Create src/features/workspace/hooks/useMergeOnSignIn.ts:

    1. Import { useEffect } from "react"
    2. Import { useAuth } from "../../auth/auth.context"
    3. Import { useConvex } from "@convex-dev/react"
    4. Import mergeDecisions from "../storage-merge.service"
    5. Import cacheFromConvex from "../storage-sync.service"

    2. useMergeOnSignIn(): void
       - Get auth state from useAuth()
       - Get Convex client from useConvex()

       - useEffect on auth.isAuthenticated and auth.user.id:
         - If isAuthenticated and user.id exists:
           - Call mergeDecisions(convex, user.id)
           - Wait for merge to complete
           - On success: Show toast notification "X decisions merged into your account"
           - On error: Show error toast

    3. For authenticated users (already signed in on load):
       - Use Convex useQuery to load decisions
       - Call cacheFromConvex with loaded decisions on first load

    4. Handle toast notifications (use a toast library like sonner or simple custom implementation):
       - Install toast library if needed: `bun add sonner` (or use existing if app has one)
       - Show toast: toast.success("X decisions merged into your account")

    IMPORTANT: Merge only happens when user signs in (transitions from not authenticated to authenticated). For users already authenticated on load, just cache from Convex.
  </action>
  <verify>
    - src/features/workspace/hooks/useMergeOnSignIn.ts exists
    - useMergeOnSignIn hook is defined
    - Effect triggers on auth.isAuthenticated change
    - Merge is called when user signs in
    - Toast notification shows merge count
    - CacheFromConvex is called for authenticated users on load
  </verify>
  <done>
    useMergeOnSignIn hook handles merge on sign-in and cache for authenticated users.
  </done>
</task>

</tasks>

<verification>
- Merge service handles local-to-Convex decision migration
- Sync service manages localStorage cache for authenticated users
- useMergeOnSignIn triggers merge on sign-in with toast notification
- Merge conflicts are resolved by regenerating UUID
- Toast shows merge count
</verification>

<success_criteria>
- Local decisions merge into authenticated account on sign-in
- Conflicting decisions are preserved with unique identifiers
- Toast notification shows merge count
- Cache from Convex populates localStorage for authenticated users
- All requirements SYN-01, SYN-02, SYN-03 are addressed at the merge/sync level
</success_criteria>

<output>
After completion, create `.planning/phases/05-persistence-auth-and-sync-security/05-04-SUMMARY.md`
</output>
